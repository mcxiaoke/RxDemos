<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>File Phantom-Operators.html in D:\git\RxDocs\operators</title>
  <link rel="stylesheet" href="../style/github-style.css">
</head>
<body>
<p>These operators have been proposed but are not part of the 1.0 release of RxJava.</p>
<ul>
<li><a href="Phantom-Operators#chunkify"><strong><code>chunkify( )</code></strong></a> — returns an iterable that periodically returns a list of items emitted by the source Observable since the last list</li>
<li><a href="Phantom-Operators#fromfuture"><strong><code>fromFuture( )</code></strong></a> — convert a Future into an Observable, but do not attempt to get the Future&#39;s value until a Subscriber subscribes</li>
<li><a href="Phantom-Operators#foreachfuture"><strong><code>forEachFuture( )</code></strong></a> — create a futureTask that will invoke a specified function on each item emitted by an Observable </li>
<li><a href="Phantom-Operators#foriterable"><strong><code>forIterable( )</code></strong></a> — apply a function to the elements of an Iterable to create Observables which are then concatenated</li>
<li><a href="Phantom-Operators#fromcancellablefuture-startcancellablefuture-and-defercancellablefuture-"><strong><code>fromCancellableFuture( )</code>, <code>startCancellableFuture( )</code>, and <code>deferCancellableFuture( )</code></strong></a> — versions of Future-to-Observable converters that monitor the subscription status of the Observable to determine whether to halt work on the Future</li>
<li><a href="Phantom-Operators#generate-and-generateabsolutetime"><strong><code>generate( )</code> and <code>generateAbsoluteTime( )</code></strong></a> — create an Observable that emits a sequence of items as generated by a function of your choosing</li>
<li><a href="Phantom-Operators#groupbyuntil"><strong><code>groupByUntil( )</code></strong></a> — a variant of the <code>groupBy</code> operator that closes any open <code>GroupedObservable</code> upon a signal from another Observable</li>
<li><a href="Phantom-Operators#multicast"><strong><code>multicast( )</code></strong></a> — represents an Observable as a Connectable Observable</li>
<li><a href="Phantom-Operators#onerrorflatmap"><strong><code>onErrorFlatMap( )</code></strong></a> — instructs an Observable to emit a sequence of items whenever it encounters an error</li>
<li><a href="Phantom-Operators#parallel"><strong><code>parallel( )</code></strong></a> — split the work done on the emissions from an Observable into multiple Observables each operating on its own parallel thread</li>
<li><a href="Phantom-Operators#parallelmerge"><strong><code>parallelMerge( )</code></strong></a> — combine multiple Observables into a smaller number of Observables, to facilitate parallelism</li>
<li><a href="Phantom-Operators#pivot"><strong><code>pivot( )</code></strong></a> — combine multiple sets of grouped observables so that they are arranged primarily by group rather than by set</li>
<li><a href="Phantom-Operators#publishlast"><strong><code>publishLast( )</code></strong></a> — represent an Observable as a Connectable Observable that emits only the last item emitted by the source Observable</li>
</ul>
<hr>
<h2 id="chunkify-">chunkify( )</h2>
<h4 id="returns-an-iterable-that-periodically-returns-a-list-of-items-emitted-by-the-source-observable-since-the-last-list">returns an iterable that periodically returns a list of items emitted by the source Observable since the last list</h4>
<p>&lt;img src=&quot;/Netflix/RxJava/wiki/images/rx-operators/B.chunkify.png&quot; width=&quot;640&quot; height=&quot;490&quot; /&gt;</p>
<p>The <code>chunkify( )</code> operator represents a blocking observable as an Iterable, that, each time you iterate over it, returns a list of items emitted by the source Observable since the previous iteration. These lists may be empty if there have been no such items emitted.</p>
<hr>
<h2 id="fromfuture-">fromFuture( )</h2>
<h4 id="convert-a-future-into-an-observable-but-do-not-attempt-to-get-the-future-s-value-until-a-subscriber-subscribes">convert a Future into an Observable, but do not attempt to get the Future&#39;s value until a Subscriber subscribes</h4>
<p>&lt;img src=&quot;/Netflix/RxJava/wiki/images/rx-operators/fromFuture.png&quot; width=&quot;640&quot; height=&quot;335&quot; /&gt;</p>
<p>The <code>fromFuture( )</code> method also converts a Future into an Observable, but it obtains this Future indirectly, by means of a function you provide. It creates the Observable immediately, but waits to call the function and to obtain the Future until a Subscriber subscribes to it.</p>
<hr>
<h2 id="foreachfuture-">forEachFuture( )</h2>
<h4 id="create-a-futuretask-that-will-invoke-a-specified-function-on-each-item-emitted-by-an-observable">create a futureTask that will invoke a specified function on each item emitted by an Observable</h4>
<p>&lt;img src=&quot;/Netflix/RxJava/wiki/images/rx-operators/B.forEachFuture.png&quot; width=&quot;640&quot; height=&quot;375&quot; /&gt;</p>
<p>The <code>forEachFuture( )</code> returns a <code>FutureTask</code> for each item emitted by the source Observable (or each item and each notification) that, when executed, will apply a function you specify to each such item (or item and notification).</p>
<hr>
<h2 id="foriterable-">forIterable( )</h2>
<h4 id="apply-a-function-to-the-elements-of-an-iterable-to-create-observables-which-are-then-concatenated">apply a function to the elements of an Iterable to create Observables which are then concatenated</h4>
<p>&lt;img src=&quot;/Netflix/RxJava/wiki/images/rx-operators/forIterable.png&quot; width=&quot;640&quot; height=&quot;310&quot; /&gt;</p>
<p><code>forIterable( )</code> is similar to <code>from(Iterable )</code> but instead of the resulting Observable emitting the elements of the Iterable as its own emitted items, it applies a specified function to each of these elements to generate one Observable per element, and then concatenates the emissions of these Observables to be its own sequence of emitted items.</p>
<hr>
<h2 id="fromcancellablefuture-startcancellablefuture-and-defercancellablefuture-">fromCancellableFuture( ), startCancellableFuture( ), and deferCancellableFuture( )</h2>
<h4 id="versions-of-future-to-observable-converters-that-monitor-the-subscription-status-of-the-observable-to-determine-whether-to-halt-work-on-the-future">versions of Future-to-Observable converters that monitor the subscription status of the Observable to determine whether to halt work on the Future</h4>
<p>If the a subscriber to the Observable that results when a Future is converted to an Observable later unsubscribes from that Observable, it can be useful to have the ability to stop attempting to retrieve items from the Future. The &quot;cancellable&quot; Future enables you do do this. These three methods will return Observables that, when unsubscribed to, will also &quot;unsubscribe&quot; from the underlying Futures.</p>
<hr>
<h2 id="generate-and-generateabsolutetime-">generate( ) and generateAbsoluteTime( )</h2>
<h4 id="create-an-observable-that-emits-a-sequence-of-items-as-generated-by-a-function-of-your-choosing">create an Observable that emits a sequence of items as generated by a function of your choosing</h4>
<p>&lt;img src=&quot;/Netflix/RxJava/wiki/images/rx-operators/generate.png&quot; width=&quot;640&quot; height=&quot;315&quot; /&gt;</p>
<p>The basic form of <code>generate( )</code> takes four parameters. These are <code>initialState</code> and three functions: <code>iterate( )</code>, <code>condition( )</code>, and <code>resultSelector( )</code>. <code>generate( )</code> uses these four parameters to generate an Observable sequence, which is its return value. It does so in the following way.</p>
<p><code>generate( )</code> creates each emission from the sequence by applying the <code>resultSelector( )</code> function to the current <em>state</em> and emitting the resulting item. The first state, which determines the first emitted item, is <code>initialState</code>. <code>generate( )</code> determines each subsequent state by applying <code>iterate( )</code> to the current state. Before emitting an item, <code>generate( )</code> tests the result of <code>condition( )</code> applied to the current state. If the result of this test is <code>false</code>, instead of calling <code>resultSelector( )</code> and emitting the resulting value, <code>generate( )</code> terminates the sequence and stops iterating the state.</p>
<p>There are also versions of <code>generate( )</code> that allow you to do the work of generating the sequence on a particular <code>Scheduler</code> and that allow you to set the time interval between emissions by applying a function to the current state. The <code>generateAbsoluteTime( )</code> allows you to control the time at which an item is emitted by applying a function to the state to get an absolute system clock time (rather than an interval from the previous emission).</p>
<p>&lt;img src=&quot;/Netflix/RxJava/wiki/images/rx-operators/generateAbsoluteTime.png&quot; width=&quot;640&quot; height=&quot;330&quot; /&gt;</p>
<h4 id="see-also-">see also:</h4>
<ul>
<li>&lt;a href=&quot;http://www.introtorx.com/Content/v1.0.10621.0/04_CreatingObservableSequences.html#ObservableGenerate&quot;&gt;Introduction to Rx: Generate&lt;/a&gt;</li>
<li>Linq: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.generate.aspx&quot;&gt;<code>Generate</code>&lt;/a&gt;</li>
<li>RxJS: &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.html#rxobservablegenerateinitialstate-condition-iterate-resultselector-scheduler&quot;&gt;<code>generate</code>&lt;/a&gt;, &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.html#rxobservablegeneratewithabsolutetimeinitialstate-condition-iterate-resultselector-timeselector-scheduler&quot;&gt;<code>generateWithAbsoluteTime</code>&lt;/a&gt;, and &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.html#rxobservablegeneratewithrelativetimeinitialstate-condition-iterate-resultselector-timeselector-scheduler&quot;&gt;<code>generateWithRelativeTime</code>&lt;/a&gt;</li>
</ul>
<hr>
<h2 id="groupbyuntil-">groupByUntil( )</h2>
<h4 id="a-variant-of-the-groupby-operator-that-closes-any-open-groupedobservable-upon-a-signal-from-another-observable">a variant of the <code>groupBy</code> operator that closes any open <code>GroupedObservable</code> upon a signal from another Observable</h4>
<p>This version of <code>groupBy</code> adds another parameter: an Observable that emits duration markers. When a duration marker is emitted by this Observable, any grouped Observables that have been opened are closed, and <code>groupByUntil( )</code> will create new grouped Observables for any subsequent emissions by the source Observable.</p>
<p>&lt;img src=&quot;/ReactiveX/RxJava/wiki/images/rx-operators/groupByUntil.png&quot; width=&quot;640&quot; height=&quot;375&quot; /&gt;​</p>
<p>Another variety of <code>groupByUntil( )</code> limits the number of groups that can be active at any particular time. If an item is emitted by the source Observable that would cause the number of groups to exceed this maximum, before the new group is emitted, one of the existing groups is closed (that is, the Observable it represents terminates by calling its Subscribers&#39; <code>onCompleted</code> methods and then expires).</p>
<hr>
<h2 id="multicast-">multicast( )</h2>
<h4 id="represents-an-observable-as-a-connectable-observable">represents an Observable as a Connectable Observable</h4>
<p>To represent an Observable as a Connectable Observable, use the <code>multicast( )</code> method.</p>
<h4 id="see-also-">see also:</h4>
<ul>
<li>javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#multicast(rx.functions.Func0)&quot;&gt;<code>multicast(subjectFactory)</code>&lt;/a&gt;</li>
<li>javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#multicast(rx.functions.Func0, rx.functions.Func1)&quot;&gt;<code>multicast(subjectFactory, selector)</code>&lt;/a&gt;</li>
<li>RxJS: &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.html#rxobservableprototypemulticastsubject--subjectselector-selector&quot;&gt;<code>multicast</code>&lt;/a&gt;</li>
<li>Linq: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.multicast.aspx&quot;&gt;<code>Multicast</code>&lt;/a&gt;</li>
<li>&lt;a href=&quot;http://www.introtorx.com/Content/v1.0.10621.0/14_HotAndColdObservables.html#PublishAndConnect&quot;&gt;Introduction to Rx: Publish and Connect&lt;/a&gt;</li>
<li>&lt;a href=&quot;http://www.introtorx.com/Content/v1.0.10621.0/14_HotAndColdObservables.html#Multicast&quot;&gt;Introduction to Rx: Multicast&lt;/a&gt;</li>
</ul>
<hr>
<h2 id="onerrorflatmap-">onErrorFlatMap( )</h2>
<h4 id="instructs-an-observable-to-emit-a-sequence-of-items-whenever-it-encounters-an-error">instructs an Observable to emit a sequence of items whenever it encounters an error</h4>
<p>&lt;img src=&quot;/Netflix/RxJava/wiki/images/rx-operators/onErrorFlatMap.png&quot; width=&quot;640&quot; height=&quot;310&quot; /&gt;​</p>
<p>The <code>onErrorFlatMap( )</code> method is similar to <code>onErrorResumeNext( )</code> except that it does not assume the source Observable will correctly terminate when it issues an error. Because of this, after emitting its backup sequence of items, <code>onErrorFlatMap( )</code> relinquishes control of the emitted sequence back to the source Observable. If that Observable again issues an error, <code>onErrorFlatMap( )</code> will again emit its backup sequence.</p>
<p>The backup sequence is an Observable that is returned from a function that you pass to <code>onErrorFlatMap( )</code>. This function takes the Throwable issued by the source Observable as its argument, and so you can customize the sequence based on the nature of the Throwable.</p>
<p>Because <code>onErrorFlatMap( )</code> is designed to work with pathological source Observables that do not terminate after issuing an error, it is mostly useful in debugging/testing scenarios.</p>
<p>Note that you should apply <code>onErrorFlatMap( )</code> directly to the pathological source Observable, and not to that Observable after it has been modified by additional operators, as such operators may effectively renormalize the source Observable by unsubscribing from it immediately after it issues an error. Below, for example, is an illustration showing how <code>onErrorFlatMap( )</code> will respond to two error-generating Observables that have been merged by the <code>merge( )</code> operator. Note that it will <em>not</em> react to both errors generated by both Observables, but only to the single error passed along by <code>merge( )</code>:</p>
<p>&lt;img src=&quot;/Netflix/RxJava/wiki/images/rx-operators/onErrorFlatMap.withMerge.png&quot; width=&quot;640&quot; height=&quot;630&quot; /&gt;​</p>
<hr>
<h2 id="parallel-">parallel( )</h2>
<h4 id="split-the-work-done-on-the-emissions-from-an-observable-into-multiple-observables-each-operating-on-its-own-parallel-thread">split the work done on the emissions from an Observable into multiple Observables each operating on its own parallel thread</h4>
<p>&lt;img src=&quot;/ReactiveX/RxJava/wiki/images/rx-operators/parallel.png&quot; width=&quot;640&quot; height=&quot;475&quot; /&gt;​</p>
<p>The <code>parallel( )</code> method splits an Observable into as many Observables as there are available processors, and does work in parallel on each of these Observables. <code>parallel( )</code> then merges the results of these parallel computations back into a single, well-behaved Observable sequence.</p>
<p>For the simple &ldquo;run things in parallel&rdquo; use case, you can instead use something like this:</p>
<pre><code class="lang-java">streamOfItems.flatMap(item -&gt; {
   itemToObservable(item).subscribeOn(Schedulers.io());
});
</code></pre>
<p>Kick off your work for each item inside <a href="Transforming-Observables#flatmap-concatmap-and-flatmapiterable"><code>flatMap</code></a> using <a href="Observable-Utility-Operators#subscribeon"><code>subscribeOn</code></a> to make it asynchronous, or by using a function that already makes asychronous calls.</p>
<h4 id="see-also-">see also:</h4>
<ul>
<li>&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt; by Graham Lea</li>
</ul>
<hr>
<h2 id="parallelmerge-">parallelMerge( )</h2>
<h4 id="combine-multiple-observables-into-a-smaller-number-of-observables-to-facilitate-parallelism">combine multiple Observables into a smaller number of Observables, to facilitate parallelism</h4>
<p>&lt;img src=&quot;/ReactiveX/RxJava/wiki/images/rx-operators/parallelMerge.png&quot; width=&quot;640&quot; height=&quot;535&quot; /&gt;​</p>
<p>Use the <code>parallelMerge( )</code> method to take an Observable that emits a large number of Observables and to reduce it to an Observable that emits a particular, smaller number of Observables that emit the same set of items as the original larger set of Observables: for instance a number of Observables that matches the number of parallel processes that you want to use when processing the emissions from the complete set of Observables.</p>
<hr>
<h2 id="pivot-">pivot( )</h2>
<h4 id="combine-multiple-sets-of-grouped-observables-so-that-they-are-arranged-primarily-by-group-rather-than-by-set">combine multiple sets of grouped observables so that they are arranged primarily by group rather than by set</h4>
<p>&lt;img src=&quot;/Netflix/RxJava/wiki/images/rx-operators/pivot.png&quot; width=&quot;640&quot; height=&quot;580&quot; /&gt;​</p>
<p>If you combine multiple sets of grouped observables, such as those created by <a href="Transforming-Observables#wiki-groupby-and-groupbyuntil"><code>groupBy( )</code> and <code>groupByUntil( )</code></a>, then even if those grouped observables have been grouped by a similar differentiation function, the resulting grouping will be primarily based on which set the observable came from, not on which group the observable belonged to.</p>
<p>An example may make this clearer. Imagine you use <code>groupBy( )</code> to group the emissions of an Observable (Observable1) that emits integers into two grouped observables, one emitting the even integers and the other emitting the odd integers. You then repeat this process on a second Observable (Observable2) that emits another set of integers. You hope then to combine the sets of grouped observables emitted by each of these into a single grouped Observable by means of a operator like <code>from(Observable1, Observable2)</code>.</p>
<p>The result will be a grouped observable that emits two groups: the grouped observable resulting from transforming Observable1, and the grouped observable resulting from transforming Observable2. Each of those grouped observables emit observables that in turn emit the odds and evens from the source observables. You can use <code>pivot( )</code> to change this around: by applying <code>pivot( )</code> to this grouped observable it will transform into one that emits two different groups: the odds group and the evens group, with each of these groups emitting a separate observable corresponding to which source observable its set of integers came from. Here is an illustration:</p>
<p>&lt;img src=&quot;/Netflix/RxJava/wiki/images/rx-operators/pivot.ex.png&quot; width=&quot;640&quot; height=&quot;1140&quot; /&gt;​</p>
<hr>
<h2 id="publishlast-">publishLast( )</h2>
<h4 id="represent-an-observable-as-a-connectable-observable-that-emits-only-the-last-item-emitted-by-the-source-observable">represent an Observable as a Connectable Observable that emits only the last item emitted by the source Observable</h4>
<p>&lt;img src=&quot;/ReactiveX/RxJava/wiki/images/rx-operators/publishLast.png&quot; width=&quot;640&quot; height=&quot;310&quot; /&gt;</p>
<h4 id="see-also-">see also:</h4>
<ul>
<li>RxJS: &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.html#rxobservableprototypepublishlatestselector&quot;&gt;<code>publishLast</code>&lt;/a&gt;</li>
<li>Linq: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.publishlast.aspx&quot;&gt;<code>PublishLast</code>&lt;/a&gt;</li>
<li>&lt;a href=&quot;http://www.introtorx.com/Content/v1.0.10621.0/14_HotAndColdObservables.html#PublishLast&quot;&gt;Introduction to Rx: PublishLast&lt;/a&gt;</li>
</ul>
</body>
<html>
