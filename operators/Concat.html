<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>File Concat.html in D:\git\RxDocs\operators</title>
  <link rel="stylesheet" href="../style/github-style.css">
</head>
<body>
<h2 id="concat">Concat</h2>
<p>不交错的发射两个或多个Observable的发射物</p>
<p><img src="../images/operators/concat.c.png" alt="concat"></p>
<p><code>Concat</code>操作符连接多个Observable的输出，就好像它们是一个Observable，第一个Observable发射的所有数据在第二个Observable发射的任何数据前面，以此类推。</p>
<p>直到前面一个Observable终止，<code>Concat</code>才会订阅额外的一个Observable。注意：因此，如果你尝试连接一个&quot;热&quot;Observable（这种Observable在创建后立即开始发射数据，即使没有订阅者），<code>Concat</code>将不会看到也不会发射它之前发射的任何数据。</p>
<p>在ReactiveX的某些实现中有一种<code>ConcatMap</code>操作符（名字可能叫<code>concat_all</code>, <code>concat_map</code>, <code>concatMapObserver</code>, <code>for</code>, <code>forIn/for_in</code>, <code>mapcat</code>, <code>selectConcat</code>或<code>selectConcatObserver</code>），他会变换原始Observable发射的数据到一个对应的Observable，然后再按观察和变换的顺序进行连接操作。</p>
<p><code>StartWith</code>操作符类似于<code>Concat</code>，但是它是插入到前面，而不是追加那些Observable的数据到原始Observable发射的数据序列。</p>
<p><code>Merge</code>操作符也差不多，它结合两个或多个Observable的发射物，但是数据可能交错，而<code>Concat</code>不会让多个Observable的发射物交错。</p>
<p><img src="../images/operators/concat.png" alt="concat"></p>
<p>RxJava中的实现叫<code>concat</code>。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable">concat(Observable&lt;Observable&gt;)</a>)</li>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable,%20rx.Observable">concat(Observable,Observable) </a>)</li>
</ul>
<p>还有一个实例方法叫<code>concatWith</code>，这两者是等价的：<code>Observable.concat(a,b)</code>和<code>a.concatWith(b)</code>。</p>
</body>
<html>
