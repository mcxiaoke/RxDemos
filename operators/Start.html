<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>File Start.html in D:\git\RxDocs\operators</title>
  <link rel="stylesheet" href="../style/github-style.css">
</head>
<body>
<h2 id="start">Start</h2>
<p>返回一个Observable，它发射一个类似于函数声明的值</p>
<p><img src="../images/operators/start.png" alt="Start"></p>
<p>编程语言有很多种方法可以从运算结果中获取值，它们的名字一般叫<code>functions, futures, actions, callables, runnables</code>等等。在<code>Start</code>目录下的这组操作符可以让它们表现得像Observable，因此它们可以在Observables调用链中与其它Observable搭配使用。</p>
<p><code>Start</code>操作符的多种RxJava实现都属于可选的<code>rxjava-async</code>模块。</p>
<p><code>rxjava-async</code>模块包含<code>start</code>操作符，它接受一个函数作为参数，调用这个函数获取一个值，然后返回一个会发射这个值给后续观察者的Observable。</p>
<p>注意：这个函数只会被执行一次，即使多个观察者订阅这个返回的Observable。</p>
<h3 id="toasync">toAsync</h3>
<p><img src="../images/operators/toAsync.png" alt="toAsync"></p>
<p><code>rxjava-async</code>模块还包含这几个操作符：<code>toAsync</code>, <code>asyncAction</code>, 和<code>asyncFunc</code>。它们接受一个函数或一个Action作为参数。</p>
<p>对于函数(functions)，这个操作符调用这个函数获取一个值，然后返回一个会发射这个值给后续观察者的Observable（和<code>start</code>一样）。对于动作(Action)，过程类似，但是没有返回值，在这种情况下，这个操作符在终止前会发射一个<code>null</code>值。</p>
<p>注意：这个函数或动作只会被执行一次，即使多个观察者订阅这个返回的Observable。</p>
<h3 id="startfuture">startFuture</h3>
<p><img src="../images/operators/startFuture.png" alt="startFuture"></p>
<p><code>rxjava-async</code>模块还包含一个<code>startFuture</code>操作符，传递给它一个返回<code>Future</code>的函数，<code>startFuture</code>会立即调用这个函数获取<code>Future</code>对象，然后调用<code>Future</code>的<code>get()</code>方法尝试获取它的值。它返回一个发射这个值给后续观察者的Observable。</p>
<h3 id="deferfuture">deferFuture</h3>
<p><img src="../images/operators/deferFuture.png" alt="deferFuture"></p>
<p><code>rxjava-async</code>模块还包含一个<code>deferFuture</code>操作符，传递给它一个返回<code>Future</code>的函数（这个<code>Future</code>返回一个<code>Observable</code>），<code>deferFuture</code>返回一个Observable，但是不会调用你提供的函数，知道有观察者订阅它返回的Observable。这时，它立即调用<code>Future</code>的<code>get()</code>方法，然后镜像发射<code>get()</code>方法返回的Observable发射的数据。</p>
<p>用这种方法，你可以在Observables调用链中包含一个返回Observable的<code>Future</code>对象。</p>
<h3 id="fromaction">fromAction</h3>
<p><img src="../images/operators/fromCallable.png" alt="fromAction"></p>
<p><code>rxjava-async</code>模块还包含一个<code>fromAction</code>操作符，它接受一个<code>Action</code>作为参数，返回一个Observable，一旦Action终止，它发射这个你传递给<code>fromAction</code>的数据。</p>
<h3 id="fromcallable">fromCallable</h3>
<p><img src="../images/operators/fromCallable.png" alt="fromCallable"></p>
<p><code>rxjava-async</code>模块还包含一个<code>fromCallable</code>操作符，它接受一个<code>Callable</code>作为参数，返回一个发射这个<code>Callable</code>的结果的Observable。</p>
<h3 id="fromrunnable">fromRunnable</h3>
<p><img src="../images/operators/fromRunnable.png" alt="fromRunnable"></p>
<p><code>rxjava-async</code>模块还包含一个<code>fromRunnable</code>操作符，它接受一个<code>Runnable</code>作为参数，返回一个Observable，一旦Runnable终止，它发射这个你传递给<code>fromRunnable</code>的数据。</p>
<h3 id="foreachfuture">forEachFuture</h3>
<p><img src="../images/operators/forEachFuture.png" alt="forEachFuture"></p>
<p><code>rxjava-async</code>模块还包含一个<code>forEachFuture</code>操作符。它其实不算<code>Start</code>操作符的一个变体，而是有一些自己的特点。你传递一些典型的观察者方法（如onNext, onError和onCompleted）给它，Observable会以通常的方式调用它。但是<code>forEachFuture</code>自己返回一个<code>Future</code>并且在<code>get()</code>方法处阻塞，直到原始Observable执行完成，然后它返回，完成还是错误依赖于原始Observable是完成还是错误。</p>
<p>如果你想要一个函数阻塞直到Observable执行完成，可以使用这个操作符。</p>
<h3 id="runasync">runAsync</h3>
<p><code>rxjava-async</code>模块还包含一个<code>runAsync</code>操作符。它很特殊，返回一个叫做<code>StoppableObservable</code>的特殊Observable。</p>
<p>传递一个<code>Action</code>和一个<code>Scheduler</code>给<code>runAsync</code>，它返回一个使用这个<code>Action</code>产生数据的<code>StoppableObservable</code>。这个<code>Action</code>接受一个<code>Observable</code>和一个<code>Subscription</code>作为参数，它使用<code>Subscription</code>检查<code>unsubscribed</code>条件，一旦发现条件为真就立即停止发射数据。在任何时候你都可以使用<code>unsubscribe</code>方法手动停止一个<code>StoppableObservable</code>（这会同时取消订阅与这个<code>StoppableObservable</code>关联的<code>Subscription</code>）。</p>
<p>由于<code>runAsync</code>会立即调用<code>Action</code>并开始发射数据，在你创建StoppableObservable之后到你的观察者准备好接受数据之前这段时间里，可能会有一部分数据会丢失。如果这不符合你的要求，可以使用<code>runAsync</code>的一个变体，它也接受一个<code>Subject</code>参数，传递一个<code>ReplaySubject</code>给它，你可以获取其它丢失的数据了。</p>
<p>在RxJava中还有一个版本的<code>From</code>操作符可以将Future转换为Observable，与<code>start</code>相似。</p>
</body>
<html>
