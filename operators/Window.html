<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>File Window.html in D:\git\RxDocs\operators</title>
  <link rel="stylesheet" href="../style/github-style.css">
</head>
<body>
<h2 id="window">Window</h2>
<p>定期将来自原始Observable的数据分解为一个Observable窗口，发射这些窗口，而不是每次发射一项数据</p>
<p><img src="../images/operators/window.C.png" alt="window"></p>
<p><code>Window</code>和<code>Buffer</code>类似，但不是发射来自原始Observable的数据包，它发射的是Observables，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个<code>onCompleted</code>通知。</p>
<p>和<code>Buffer</code>一样，<code>Window</code>有很多变体，每一种都以自己的方式将原始Observable分解为多个作为结果的Observable，每一个都包含一个映射原始数据的<code>window</code>。用<code>Window</code>操作符的术语描述就是，当一个窗口打开(when a window &quot;opens&quot;)意味着一个新的Observable已经发射（产生）了，而且这个Observable开始发射来自原始Observable的数据；当一个窗口关闭(when a window &quot;closes&quot;)意味着发射(产生)的Observable停止发射原始Observable的数据，并且发射终止通知<code>onCompleted</code>给它的观察者们。</p>
<p>在RxJava中有许多种<code>Window</code>操作符的变体。</p>
<h3 id="window-closingselector-">window(closingSelector)</h3>
<p><img src="../images/operators/window1.png" alt="window1"></p>
<p><code>window</code>的这个变体会立即打开它的第一个窗口。每当它观察到<code>closingSelector</code>返回的Observable发射了一个对象时，它就关闭当前打开的窗口并立即打开一个新窗口。用这个方法，这种<code>window</code>变体发射一系列不重叠的窗口，这些窗口的数据集合与原始Observable发射的数据是一一对应的。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.functions.Func0">window(Func0)</a>)</li>
</ul>
<h3 id="window-windowopenings-closingselector-">window(windowOpenings, closingSelector)</h3>
<p><img src="../images/operators/window2.png" alt="window2"></p>
<p>无论何时，只要<code>window</code>观察到<code>windowOpenings</code>这个Observable发射了一个<code>Opening</code>对象，它就打开一个窗口，并且同时调用<code>closingSelector</code>生成一个与那个窗口关联的关闭(closing)Observable。当这个关闭(closing)Observable发射了一个对象时，<code>window</code>操作符就会关闭那个窗口。对这个变体来说，由于当前窗口的关闭和新窗口的打开是由单独的Observable管理的，它创建的窗口可能会存在重叠（重复某些来自原始Observable的数据）或间隙（丢弃某些来自原始Observable的数据）。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.Observable,%20rx.functions.Func1">window(Observable,Func1)</a>)</li>
</ul>
<h3 id="window-count-">window(count)</h3>
<p><img src="../images/operators/window3.png" alt="window3"></p>
<p>这个<code>window</code>的变体立即打开它的第一个窗口。每当当前窗口发射了<code>count</code>项数据，它就关闭当前窗口并打开一个新窗口。如果从原始Observable收到了<code>onError</code>或<code>onCompleted</code>通知它也会关闭当前窗口。这种<code>window</code>变体发射一系列不重叠的窗口，这些窗口的数据集合与原始Observable发射的数据是一一对应的。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int">window(int)</a>)</li>
</ul>
<h3 id="window-count-skip-">window(count, skip)</h3>
<p><img src="../images/operators/window4.png" alt="window4"></p>
<p>这个<code>window</code>的变体立即打开它的第一个窗口。原始Observable每发射<code>skip</code>项数据它就打开一个新窗口（例如，如果<code>skip</code>等于3，每到第三项数据，它会打开一耳光新窗口）。每当当前窗口发射了<code>count</code>项数据，它就关闭当前窗口并打开一个新窗口。如果从原始Observable收到了<code>onError</code>或<code>onCompleted</code>通知它也会关闭当前窗口。如果<code>skip=count</code>，它的行为与<code>window(source, count)</code>相同；如果<code>skip &lt; count</code>，窗口可会有<code>count - skip</code> 个重叠的数据；如果<code>skip &gt; count</code>，在两个窗口之间会有<code>skip - count</code>项数据被丢弃。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int,%20int">window(int,int)</a>)</li>
</ul>
<h3 id="window-timespan-unit-scheduler-">window(timespan, unit[, scheduler])</h3>
<p><img src="../images/operators/window5.png" alt="window5"></p>
<p>这个<code>window</code>的变体立即打开它的第一个窗口。每当过了<code>timespan</code>这么长的时间它就关闭当前窗口并打开一个新窗口（时间单位是<code>unit</code>，可选在调度器<code>scheduler</code>上执行）。如果从原始Observable收到了<code>onError</code>或<code>onCompleted</code>通知它也会关闭当前窗口。这种<code>window</code>变体发射一系列不重叠的窗口，这些窗口的数据集合与原始Observable发射的数据也是一一对应的。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit">window(long,TimeUnit)</a>)</li>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler">window(long,TimeUnit,Scheduler)</a>)</li>
</ul>
<h3 id="window-timespan-unit-count-scheduler-">window(timespan, unit, count[, scheduler])</h3>
<p><img src="../images/operators/window6.png" alt="window6"></p>
<p>这个<code>window</code>的变体立即打开它的第一个窗口。这个变体是<code>window(count)</code>和<code>window(timespan, unit[, scheduler])</code>的结合，每当过了<code>timespan</code>的时长或者当前窗口收到了<code>count</code>项数据，它就关闭当前窗口并打开另一个。如果从原始Observable收到了<code>onError</code>或<code>onCompleted</code>通知它也会关闭当前窗口。这种<code>window</code>变体发射一系列不重叠的窗口，这些窗口的数据集合与原始Observable发射的数据也是一一对应的。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20int">window(long,TimeUnit,int)</a>)</li>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler">window(long,TimeUnit,int,Scheduler)</a>)</li>
</ul>
<h3 id="window-timespan-timeshift-unit-scheduler-">window(timespan, timeshift, unit[, scheduler])</h3>
<p><img src="../images/operators/window7.png" alt="window7"></p>
<p><code>buffer(timespan, timeshift, unit)</code>在每一个<code>timeshift</code>时期内都创建一个新的<code>List</code>,然后用原始Observable发射的每一项数据填充这个列表（在把这个<code>List</code>当做自己的数据发射前，从创建时开始，直到过了<code>timespan</code>这么长的时间）。如果<code>timespan</code>长于<code>timeshift</code>，它发射的数据包将会重叠，因此可能包含重复的数据项。</p>
<p>这个<code>window</code>的变体立即打开它的第一个窗口。随后每当过了<code>timeshift</code>的时长就打开一个新窗口（时间单位是<code>unit</code>，可选在调度器<code>scheduler</code>上执行），当窗口打开的时长达到<code>timespan</code>，它就关闭当前打开的窗口。如果从原始Observable收到了<code>onError</code>或<code>onCompleted</code>通知它也会关闭当前窗口。窗口的数据可能重叠也可能有间隙，取决于你设置的<code>timeshift</code>和<code>timespan</code>的值。</p>
<p>这个变体的<code>window</code>默认在<code>computation</code>调度器上执行它的定时器。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit">window(long,long,TimeUnit)</a>)</li>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler">window(long,long,TimeUnit,Scheduler)</a>)</li>
</ul>
<h3 id="window-backpressure">window-backpressure</h3>
<p>你可以使用<code>Window</code>操作符实现反压<code>backpressure</code>（意思是，处理这样一个Observable：它产生数据的数据可能比它的观察者消费数据的数据快）。</p>
<p><img src="../images/operators/bp.window1.png" alt="bp.window1"></p>
<p>Window操作符可以将大量的数据序列缩减为较少的数据窗口序列，让它们更容易处理。例如，你可以按固定的时间间隔，定期关闭和发射来自一个爆发性Observable的数据窗口。</p>
<p>示例代码</p>
<pre><code class="lang-java">Observable&lt;Observable&lt;Integer&gt;&gt; burstyWindowed = bursty.window(500, TimeUnit.MILLISECONDS);
</code></pre>
<p><img src="../images/operators/bp.window2.png" alt="bp.window2"></p>
<p>你还可以选择每当收到爆发性Observable的N项数据时发射一个新的数据窗口。</p>
<p>示例代码</p>
<pre><code class="lang-java">Observable&lt;Observable&lt;Integer&gt;&gt; burstyWindowed = bursty.window(5);
</code></pre>
</body>
<html>
