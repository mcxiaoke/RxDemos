<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>File ObserveOn.html in D:\git\RxDocs\operators</title>
  <link rel="stylesheet" href="../style/github-style.css">
</head>
<body>
<h2 id="observeon">ObserveOn</h2>
<p>指定一个观察者在哪个调度器上观察这个Observable</p>
<p><img src="../images/operators/observeOn.c.png" alt="observeOn"></p>
<p>很多ReactiveX实现都使用调度器 <a href="Scheduler.html">&quot;<code>Scheduler</code>&quot;</a>来管理多线程环境中Observable的转场。你可以使用<code>ObserveOn</code>操作符指定Observable在一个特定的调度器上发送通知给观察者 (调用观察者的<code>onNext</code>, <code>onCompleted</code>, <code>onError</code>方法)。</p>
<p><img src="../images/operators/observeOn.e.png" alt="observeOn"></p>
<p>注意：当遇到一个异常时<code>ObserveOn</code>会立即向前传递这个<code>onError</code>终止通知，它不会等待慢速消费的Observable接受任何之前它已经收到但还没有发射的数据项。这可能意味着<code>onError</code>通知会跳到（并吞掉）原始Observable发射的数据项前面，正如图例上展示的。</p>
<p><code>SubscribeOn</code>操作符的作用类似，但它是用于指定Observable本身在特定的调度器上执行，它同样会在那个调度器上给观察者发通知。</p>
<p>RxJava中，要指定Observable应该在哪个调度器上调用观察者的<code>onNext</code>, <code>onCompleted</code>, <code>onError</code>方法，你需要使用<code>observeOn</code>操作符，传递给它一个合适的<code>Scheduler</code>。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#observeOn(rx.Scheduler">observeOn(Scheduler)</a>)</li>
</ul>
</body>
<html>
