<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>File To.html in D:\git\RxDocs\operators</title>
  <link rel="stylesheet" href="../style/github-style.css">
</head>
<body>
<h2 id="to">To</h2>
<p>将Observable转换为另一个对象或数据结构</p>
<p><img src="../images/operators/to.c.png" alt="to"></p>
<p>ReactiveX的很多语言特定实现都有一种操作符让你可以将Observable或者Observable发射的数据序列转换为另一个对象或数据结构。它们中的一些会阻塞直到Observable终止，然后生成一个等价的对象或数据结构；另一些返回一个发射那个对象或数据结构的Observable。</p>
<p>在某些ReactiveX实现中，还有一个操作符用于将Observable转换成阻塞式的。一个阻塞式的Ogbservable在普通的Observable的基础上增加了几个方法，用于操作Observable发射的数据项。</p>
<h3 id="getiterator">getIterator</h3>
<p><img src="../images/operators/B.getIterator.png" alt="getIterator"></p>
<p><code>getIterator</code>操作符只能用于<code>BlockingObservable</code>的子类，要使用它，你首先必须把原始的Observable转换为一个<code>BlockingObservable</code>。可以使用这两个操作符：<code>BlockingObservable.from</code>或<code>the Observable.toBlocking</code>。</p>
<p>这个操作符将Observable转换为一个<code>Iterator</code>，你可以通过它迭代原始Observable发射的数据集。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#getIterator(">BlockingObservable.getIterator()</a>)</li>
</ul>
<h3 id="tofuture">toFuture</h3>
<p><img src="../images/operators/B.toFuture.png" alt="toFuture"></p>
<p><code>toFuture</code>操作符也是只能用于<code>BlockingObservable</code>。这个操作符将Observable转换为一个返回单个数据项的<code>Future</code>，如果原始Observable发射多个数据项，<code>Future</code>会收到一个<code>IllegalArgumentException</code>；如果原始Observable没有发射任何数据，<code>Future</code>会收到一个<code>NoSuchElementException</code>。</p>
<p>如果你想将发射多个数据项的Observable转换为<code>Future</code>，可以这样用：<code>myObservable.toList().toBlocking().toFuture()</code>。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toFuture(">BlockingObservable.toFuture()</a>)</li>
</ul>
<h3 id="toiterable">toIterable</h3>
<p><img src="../images/operators/B.toIterable.png" alt="toIterable"></p>
<p><code>toFuture</code>操作符也是只能用于<code>BlockingObservable</code>。这个操作符将Observable转换为一个<code>Iterable</code>，你可以通过它迭代原始Observable发射的数据集。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toIterable(">BlockingObservable.toIterable()</a>)</li>
</ul>
<h3 id="tolist">toList</h3>
<p><img src="../images/operators/toList.png" alt="toList"></p>
<p>通常，发射多项数据的Observable会为每一项数据调用<code>onNext</code>方法。你可以用<code>toList</code>操作符改变这个行为，让Observable将多项数据组合成一个<code>List</code>，然后调用一次<code>onNext</code>方法传递整个列表。</p>
<p>如果原始Observable没有发射任何数据就调用了<code>onCompleted</code>，<code>toList</code>返回的Observable会在调用<code>onCompleted</code>之前发射一个空列表。如果原始Observable调用了<code>onError</code>，<code>toList</code>返回的Observable会立即调用它的观察者的<code>onError</code>方法。</p>
<p><code>toList</code>默认不在任何特定的调度器上执行。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toList(">toList()</a>)</li>
</ul>
<h3 id="tomap">toMap</h3>
<p><img src="../images/operators/toMap.png" alt="toMap"></p>
<p><code>toMap</code>收集原始Observable发射的所有数据项到一个Map（默认是HashMap）然后发射这个Map。你可以提供一个用于生成Map的Key的函数，还可以提供一个函数转换数据项到Map存储的值（默认数据项本身就是值）。</p>
<p><code>toMap</code>默认不在任何特定的调度器上执行。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1">toMap(Func1)</a>)</li>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1,%20rx.functions.Func1">toMap(Func1,Func1)</a>)</li>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0">toMap(Func1,Func1,Func0)</a>)</li>
</ul>
<h3 id="tomultimap">toMultiMap</h3>
<p><img src="../images/operators/toMultiMap.png" alt="toMultiMap"></p>
<p><code>toMultiMap</code>类似于<code>toMap</code>，不同的是，它生成的这个Map同时还是一个<code>ArrayList</code>（默认是这样，你可以传递一个可选的工厂方法修改这个行为）。</p>
<p><code>toMultiMap</code>默认不在任何特定的调度器上执行。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1">toMultiMap(Func1)</a>)</li>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1">toMultiMap(Func1,Func1)</a>)</li>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0">toMultiMap(Func1,Func1,Func0)</a>)</li>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0,%20rx.functions.Func1">toMultiMap(Func1,Func1,Func0,Func1)</a>)</li>
</ul>
<h3 id="tosortedlist">toSortedList</h3>
<p><img src="../images/operators/toSortedList.png" alt="toSortedList"></p>
<p><code>toSortedList</code>类似于<code>toList</code>，不同的是，它会对产生的列表排序，默认是自然升序，如果发射的数据项没有实现<code>Comparable</code>接口，会抛出一个异常。然而，你也可以传递一个函数作为用于比较两个数据项，这是<code>toSortedList</code>不会使用<code>Comparable</code>接口。</p>
<p><code>toSortedList</code>默认不在任何特定的调度器上执行。</p>
<ul>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList(">toSortedList()</a>)</li>
<li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList(rx.functions.Func2">toSortedList(Func2)</a>)</li>
</ul>
<h3 id="nest">nest</h3>
<p><img src="../images/operators/nest.png" alt="nest"></p>
<p><code>nest</code>操作符有一个特殊的用途：将一个Observable转换为一个发射这个Observable的Observable。</p>
</body>
<html>
